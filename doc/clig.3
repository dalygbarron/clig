.TH clig 3
.SH NAME
\fBclig\fR - A Toolkit for building REPLs and applications that use them under
the hood.

.SH DESCRIPTION
The core functionality of clig is a system to make your application master of
another application which implements some kind of REPL, and to have listeners
setup such that they listen for your application to send certain requests to
the REPL, but they are triggered when the REPL's response is also available.
This means that it doesn't matter so much if the REPL's conversational style is
rather noisy since your listeners will know by your command when what they are
looking for can be found.

It also provides some basic functionality to help build a REPL based application
yourself so you can for example use it as a way of splitting the model and view
in a GUI app (I anticipate GUI applications to be the primary use case for this
library), and it provides various other things that may be useful when building
applications in this way.

.SH TYPE DEFINITIONS
.SS typedef enum clig_input_result
Not sure if this is actually gonna be used tbh

.SS typedef clig_input_result (*clig_input_handler)(char const *);

.SS size_t (*clig_hash_func)(void const *)
Hashing function, takes a pointer to whatever kind of key you are using and then
you can hash it however you like.

.SS void (*clig_map_free_cb)(void*)
Definition for callback used to free objects that are destroyed in a map.

.SS struct clig_vector_t
Opaque vector type which is similar to a normal array except it
can grow and shrink and all of that kind of stuff. Some operations change the
order of the items in the vector by moving items to/from the back, so the order
does not remain consistent after calling those functions.
You might also notice that there is no sorting facility. This is because you
can access the buffer yourself and use a standard sorting function like
\fBqsort\fR.

.SS struct clig_map_t
Opaque hash map type.

.SH REPL FUNCTIONS
.SS int clig_main(int argc, char const **argv)
yeah nah yeah nah this is for the CLI application.

.SS void clig_add_input_handler(char const *prefix, clig_input_handler_t cb);
Only useful on CLI. Registers a new input handler that will be triggered
whenever an input line is received that begins with the provided prefix.
You should not add two input handlers where one's prefix is a subset of
another but I haven't bothered to make anything specific bad happen if you do
so it is UB I suppose.

.SH VECTOR FUNCTIONS


.SS clig_vector_t *clig_make_vector(size_t element_size)
Creates a vector object. element_size is the amount of bytes to allocate to each
item in the vector.

.SS void clig_vector_insert(clig_vector_t *v, void const *item, size_t index)
Inserts an element into the vector at the given index, thus increasing the size
of the vector by 1, and changing the ordering of elements.
The element is inserted by copying the value pointed to by item.

.SS void clig_vector_remove(clig_vector_t *v, size_t index)
Removes the element at the given index of the vector, thus decreasing the size
by 1 and altering the order of elements.

.SS void clig_vector_push(clig_vector_t *v, void const *item)
Adds an item to the end of the vector. By doing so, it does not modify the order
of elements. Works by copying like \fBclig_vector_insert\fR.

.SS void clig_vector_pop(clig_vector_t *v, void *dst)
Removes the last element of the vector and copies it to dst. Because it comes
from the end, the order of elements is undisturbed. Also, if you pass NULL to
dst then it will just remove.

.SS void clig_vector_peek(clig_vector_t *v, size_t index, void *dst)
Gets the value of the element at the given index in the vector by copying it
to the location pointed to by dst. Make sure there is enough room for it.

.SS size_t clig_vector_size(clig_vector_t const *v)
Tells you how many items are currently in the vector.

.SS void clig_vector_trim(clig_vector_t *v, size_t margin)
Useful to call after you have added all the stuff you intend to for the
time being and are conscious of memory usage. It resizes the buffer to be
equal to the highest of these three values: minimum size, capacity + margin, or
capacity + 1 (ie margin cannot be meaningfully less than 1).

.SS void clig_vector_clear(clig_vector_t *v)
Sets the vector to have 0 items in it and resizes the buffer to the starting
size.

.SS void *clig_vector_get_buffer(clig_vector_t *v)
Returns a pointer to the start of the buffer where all the items are stored.
Data should be contiguous etc, and you should just be able to cast it to your
type and iterate over it as long as you don't exceed the value of
\fBclig_vector_size\fR as queried immediately before using this.
Obviously don't keep hold of this reference because it is liable to be
invalidated when you perform other operations on the vector.
Also keep in mind that if your type has some sort of freaky alignment attribute
then this could potentially result in unaligned access which is bad but if you
dunno what I am talking about then I guess you are probably safe.

.SS void clig_vector_free(clig_vector_t *v);
Destroys the vector along with the data in it. If you're storing a bunch of
pointers then freeing them is your job.

.SH MAP FUNCTIONS
.SS clig_map_t *clig_map_make(size_t element_size)
Creates a new map and you must tell it the size in bytes all elements of the
map will share. In the unlikely event of the system running out of memory this
function will return NULL.

.SS void clig_map_insert(clig_map_t *m, char const *key, void const *src)
Inserts an element into the map with the given key. The key is copied so don't
worry about needing to keep it alive or anything.

.SS int clig_map_get(clig_map_t *m, char const *key, void *dst);
Tries to get the element with the given key in the map but the return value
tells you if it was able to or not (may not exist). If it failed then the
data pointed to by dst will be unchanged.

.SS size_t clig_map_size(clig_map_t const *m);
Tells you how many items are in the map right now.

.SS void clig_map_free(clig_map_t *m);
Frees the map and it's internal buffer. Does not free any pointers you may
have been storing in the map of course.


.SH EXAMPLE PROGRAM
When I get around to it, I will provide here the source code for a crappy
file browser that uses the bash shell as it's underlying REPL.
Pain in the ass part of that will be that it needs a GUI system to go with it
but who cares? I'll just use xforms and let people figure the rest out
themselves.
